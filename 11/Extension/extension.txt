todo get number of hash nodes for some progs.
todo: run scripts built to test the memory usage (eg: writing )

I decided on a hashing implementation that is O(N) for storage. 
In speed, the approach is O(1 + the number of elements that are in that hash)
which will depend on indexes that the data writes to.
Crutially, the new data structure does not gaurentee order
this is demonstrated in the output of isfactorial, where the output
is unordered.

My hash function is really simple 
- just a modulus of the space in the array. 
The initial size of the table is 15,319 
which I decided on because it was a prime number and allowed
sieve and fibmemo to run without any collisions 
ie: O(1) time for insertion and deletion.

To time the scripts I created a bash script that ran
each 20 times, and returned the average user time 
(to 6 decimal places). 
- fibmemo ran at the same speed in both (less than 1% difference)
- sieve was 57% faster in the extension
- isfactorial was 8% faster in the extension, but doesn't
preserve the order when printed.

I then used valgrind with --tool=massif 
to determine how much memory was used at peak.
For all three programs, the extension caused 
a 99.99% decrease in peak 
memory usage, from 4.3GB to less than 130KB
I believe that this is 0(N) memory uage.

Sources: I referenced the CS50 implementation of a hash table.
https://youtu.be/nvzVHwrrub0
as well as the in class implementation of a linked list.
